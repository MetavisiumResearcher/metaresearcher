<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#000">
<title>MetaVisium By DP</title>
<link rel="icon" type="image/png" sizes="64x64" href="favicon.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="192x192" href="icon-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="icon-512x512.png">
<style>
  :root {
    --bg: #000;
    --panel: #111;
    --muted: #222;
    --accent: #0ff;
    --neon-pink: #f0f;
    --neon-blue: #0ff;
    --neon-green: #0f0;
    --neon-purple: #9370DB;
    --neon-red: #ff073a;
    color-scheme: dark;
  }
  button:focus,
  input[type="range"]:focus,
  input[type="file"]:focus,
  select:focus {
    outline: none;
    box-shadow: none;
  }
  html,body {
    height:100%;
    margin:0;
    font-family: 'Courier New', monospace;
    background:var(--bg);
    color:#fff;
    overflow-x: hidden;
    overflow-y: auto;
    touch-action: manipulation;
  }
  header {
    padding:8px 6px;
    text-align:center;
    background:var(--panel);
    border-bottom: 1px solid var(--neon-blue);
    box-shadow: 0 0 8px var(--neon-blue);
    position: relative;
    z-index: 100;
  }
  h1 {
    margin:0;
    font-size:16px;
    text-shadow: 0 0 4px var(--neon-blue), 0 0 8px var(--neon-blue);
    color: var(--neon-blue);
    letter-spacing: 1px;
  }
  #main {
    display:flex;
    flex-direction: column;
    height: calc(100% - 60px);
    gap:4px;
    padding:4px;
    box-sizing:border-box;
    position: relative;
  }
  #quadrante-wrapper {
    position: relative;
    width: 100%;
    height: 70vh;
    overflow: hidden;
  }
  .quadrante {
    width: 100%;
    height: 100%;
    background:#000;
    position:relative;
    overflow:hidden;
    min-height:120px;
    border-radius:4px;
    transition: all 0.5s ease;
    cursor: pointer;
  }
  .quadrante.expanded {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    box-shadow: 0 0 20px var(--neon-blue);
    border: 2px solid var(--neon-blue);
  }
  .quadrante.off {
    background: #000 !important;
    box-shadow: 0 0 15px #f00, inset 0 0 10px #300;
    border: 1px solid #f00;
  }
  .quadrante.off canvas,
  .quadrante.off video {
    display: none !important;
  }
  .monitor-spento {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #f00;
    font-size: 18px;
    font-weight: bold;
    text-shadow: 0 0 8px #f00;
    z-index: 100;
    display: none;
  }
  .quadrante.off .monitor-spento {
    display: block;
  }
  .quadrante.off.expanded .monitor-spento {
    display: none;
  }
  canvas, video {
    width:100%;
    height:100%;
    display:block;
    object-fit:cover;
  }
#settings-banner {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background: rgba(17, 17, 17, 0.95);
    backdrop-filter: blur(8px);
    padding: 8px;
    border-top: 1px solid var(--neon-green);
    box-shadow: 0 -2px 6px rgba(0, 255, 0, 0.3);
    z-index: 95;
    max-height: 60vh;
    overflow-y: auto;
    display: none;
    transition: all 0.3s ease;
    /* 👇 Aggiungi questa riga */
    box-sizing: border-box;
}
  #settings-banner.active {
    display: block;
  }
  #settings-banner h3 {
    font-size: 14px;
    margin: 0 0 4px 0;
    padding: 2px 4px;
    color: var(--neon-pink);
    text-shadow: 0 0 2px var(--neon-pink);
  }
  #settings-banner label {
    font-size: 10px;
    margin: 0;
    color: var(--neon-green);
    text-shadow: 0 0 1px var(--neon-green);
  }
  #settings-banner .slider-group {
    margin: 4px 0;
    display: flex;
    flex-direction: column;
    gap: 2px;
    padding: 6px 0;
  }
  .custom-slider {
    position: relative;
    height: 4px;
    background: #333;
    border-radius: 2px;
    cursor: pointer;
    width: 100%;
  }
  .custom-slider-track {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: var(--neon-red);
    border-radius: 2px;
    pointer-events: none;
  }
  .custom-slider-thumb {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 18px;
    height: 18px;
    background: var(--neon-red);
    border: 2px solid #fff;
    border-radius: 50%;
    cursor: grab;
    box-shadow: 0 0 4px var(--neon-red);
    pointer-events: all;
  }
  .custom-slider-thumb:active {
    cursor: grabbing;
  }
  #settings-banner .value-display {
    font-size: 12px;
    min-width: 80px;
    text-align: center;
    color: #ff9900;
    font-weight: bold;
    text-shadow: 0 0 4px rgba(255, 153, 0, 0.7);
    background-color: rgba(0, 0, 0, 0.5);
    padding: 2px 6px;
    border-radius: 8px;
    border: 1px solid #ff9900;
  }
  #settings-banner button.small {
    padding: 4px 6px;
    font-size: 9px;
    margin: 0 1px 0 0;
    line-height: 1;
  }
  #settings-banner .note {
    font-size: 9px;
    margin: 2px 0 0 0;
    color: #999;
  }
  #toggle-settings-btn {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 96;
    background: var(--neon-green);
    color: #000;
    border: 1px solid var(--neon-green);
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: bold;
    box-shadow: 0 0 6px var(--neon-green);
    cursor: pointer;
  }
  #toggle-settings-btn:hover {
    background: var(--bg);
    color: var(--neon-green);
  }
  #fixed-buttons {
    display: flex;
    justify-content: space-between;
    padding: 4px 6px;
    background: var(--panel);
    border-bottom: 1px solid var(--neon-blue);
    position: relative;
    z-index: 99;
  }
  .fullscreen-btn,
  .exit-fullscreen-btn,
  .video-frame-btn {
    background: var(--muted);
    border: 1px solid var(--neon-blue);
    color: var(--neon-blue);
    padding: 2px 6px;
    cursor: pointer;
    border-radius: 3px;
    font-size: 10px;
    text-align: center;
    text-decoration: none;
  }
  .fullscreen-btn {
    width: 120px;
  }
  .exit-fullscreen-btn {
    width: 160px;
    display: none;
  }
  .video-frame-btn {
    width: 90px;
    padding: 4px 8px;
    border-radius: 30px;
    font-size: 11px;
    font-weight: bold;
    transition: all 0.2s ease;
  }
  .video-frame-btn:hover {
    background: var(--neon-blue);
    color: var(--bg);
    box-shadow: 0 0 6px var(--neon-blue);
    transform: scale(1.03);
  }
  #video-frame-page {
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg);
    z-index: 1000;
    padding: 6px;
    box-sizing: border-box;
    flex-direction: column;
    overflow-y: auto;
  }
  #video-frame-page.active {
    display: flex;
  }
  #video-frame-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 6px 0;
    border-bottom: 1px solid var(--neon-blue);
    position: relative;
  }
  #back-to-main {
    margin-top: 6px;
    align-self: center;
    background: var(--neon-red) !important;
    border-color: var(--neon-red) !important;
    box-shadow: 0 0 8px var(--neon-red);
    padding: 4px 8px !important;
    font-weight: bold;
    border-radius: 20px;
    font-size: 11px;
  }
  #video-frame-title {
    margin: 0;
    font-size: 16px;
    text-shadow: 0 0 4px var(--neon-blue), 0 0 8px var(--neon-blue);
    color: var(--neon-blue);
    letter-spacing: 1px;
  }
  #video-frame-subtitle {
    margin: 2px 0 0 0;
    font-size: 10px;
    color: var(--neon-green);
    text-shadow: 0 0 2px var(--neon-green);
  }
  #video-frame-content {
    display: flex;
    flex-direction: column;
    flex: 1;
    gap: 10px;
    padding: 10px 0;
  }

#video-frame-canvas-container {
  width: 100%;
  max-height: 50vh;
  overflow: hidden;
  background: #000;
  border: 1px solid var(--neon-green);
  cursor: grab;
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 10px;
  box-sizing: border-box;
}

#video-frame-canvas {
  max-width: 100%;
  max-height: 100%;
  /* transition: transform 0.1s ease; */
  /* user-select: none; */
  /* display: block; */
  /* object-fit: contain; */
  /* Questi sono gestiti dal JS! */
}
  #video-frame-controls {
    width: 100%;
    background: var(--panel);
    padding: 10px;
    border-radius: 6px;
    border: 1px solid var(--neon-green);
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-sizing: border-box;
  }
  /* 👇 STILE CYBERPUNK NEON PER I BOTTONI DEL VIDEO FRAME */
.cyberpunk-btn {
    background: transparent !important;
    border: 2px solid var(--neon-green) !important;
    color: var(--neon-green) !important;
    font-family: 'Courier New', monospace;
    font-size: 12px !important;
    font-weight: bold !important;
    padding: 8px 14px !important;
    border-radius: 6px !important;
    cursor: pointer !important;
    text-shadow: 0 0 5px var(--neon-green), 0 0 10px var(--neon-green) !important;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5) !important;
    transition: all 0.3s ease !important;
    letter-spacing: 1px !important;
    min-width: 120px;
    text-align: center;
    overflow: hidden;
    position: relative;
    z-index: 1;
}

.cyberpunk-btn::before {
    content: '';
    position: absolute;
    top: -10px;
    left: -10px;
    right: -10px;
    bottom: -10px;
    border: 2px solid var(--neon-green);
    border-radius: 10px;
    opacity: 0;
    transition: opacity 0.4s ease;
    z-index: -1;
    animation: pulse-neon 2s infinite alternate;
}

.cyberpunk-btn:hover {
    color: var(--neon-blue) !important;
    border-color: var(--neon-blue) !important;
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.7) !important;
    text-shadow: 0 0 8px var(--neon-blue), 0 0 15px var(--neon-blue) !important;
    transform: scale(1.05) !important;
}

.cyberpunk-btn:hover::before {
    opacity: 1;
}

@keyframes pulse-neon {
    from { opacity: 0.3; transform: scale(1); }
    to   { opacity: 0.9; transform: scale(1.1); }
}

/* Effetto flicker leggero per realismo */
.cyberpunk-btn:nth-child(3) { animation: flicker 3s infinite; } /* Crea Fotogrammi */
.cyberpunk-btn:nth-child(4) { animation: flicker 4s infinite 0.5s; } /* Annulla */
.cyberpunk-btn:nth-child(6) { animation: flicker 3.5s infinite 1s; } /* Indietro */
.cyberpunk-btn:nth-child(7) { animation: flicker 4.5s infinite 1.5s; } /* Avanti */
.cyberpunk-btn:nth-child(8) { animation: flicker 3s infinite 2s; } /* Negativo */
.cyberpunk-btn:nth-child(9) { animation: flicker 4s infinite 2.5s; } /* Grigio */
.cyberpunk-btn:nth-child(10) { animation: flicker 3.5s infinite 3s; } /* UV */
.cyberpunk-btn:nth-child(11) { animation: flicker 4s infinite 3.5s; } /* Specchio */
.cyberpunk-btn:nth-child(12) { animation: flicker 3s infinite 4s; } /* Reset */
.cyberpunk-btn:nth-child(13) { animation: flicker 4.5s infinite 4.5s; } /* Tutti i Frame */
.cyberpunk-btn:nth-child(14) { animation: flicker 3.5s infinite 5s; } /* Salva */

@keyframes flicker {
    0%, 100% { opacity: 1; }
    49% { opacity: 0.9; }
    51% { opacity: 0.7; }
    53% { opacity: 0.9; }
    55% { opacity: 0.6; }
    57% { opacity: 0.9; }
    59% { opacity: 0.7; }
    61% { opacity: 0.9; }
    63% { opacity: 0.8; }
    65% { opacity: 0.9; }
}

/* Rendi più piccoli i bottoni .small */
.cyberpunk-btn.small {
    padding: 6px 10px !important;
    font-size: 11px !important;
    min-width: 100px !important;
}
/* 👇 STILE CYBERPUNK PER IL BOTTONE FILE NASCOSTO */
.file-input-container {
    position: relative;
    margin-bottom: 10px;
}

.file-input-container input[type="file"] {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    opacity: 0;
    cursor: pointer;
    z-index: 2;
}

.cyberpunk-file-label {
    font-family: 'Courier New', monospace;
    font-size: 12px !important;
    font-weight: bold !important;
    color: var(--neon-green) !important;
    text-shadow: 0 0 3px var(--neon-green), 0 0 6px var(--neon-green) !important;
    padding: 8px 14px !important;
    border: 2px solid var(--neon-green) !important;
    background: transparent !important;
    border-radius: 6px !important;
    display: inline-block;
    cursor: pointer;
    letter-spacing: 1px;
    min-width: 120px;
    text-align: center;
    transition: all 0.3s ease !important;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5) !important;
    position: relative;
    z-index: 1;

}

.cyberpunk-file-label:hover {
    color: var(--neon-blue) !important;
    border-color: var(--neon-blue) !important;
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.7) !important;
    text-shadow: 0 0 8px var(--neon-blue), 0 0 15px var(--neon-blue) !important;
    transform: scale(1.05) !important;
}

.cyberpunk-file-label:hover::before {
    opacity: 1;
}
#extractionFps {
    font-family: 'Courier New', monospace;
    font-size: 12px !important;
    font-weight: bold !important;
    color: var(--neon-green) !important;
    text-shadow: 0 0 3px var(--neon-green), 0 0 6px var(--neon-green) !important;
    background: transparent !important;
    border: 2px solid var(--neon-green) !important;
    border-radius: 6px !important;
    padding: 6px 10px !important;
    cursor: pointer !important;
    min-width: 120px;
    box-shadow: 0 0 15px rgba(0, 255, 0, 0.5) !important;
    transition: all 0.3s ease !important;
}

#extractionFps:hover,
#extractionFps:focus {
    color: var(--neon-blue) !important;
    border-color: var(--neon-blue) !important;
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.7) !important;
    text-shadow: 0 0 8px var(--neon-blue), 0 0 15px var(--neon-blue) !important;
}
  .frame-nav {
    display: flex;
    gap: 6px;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
  }
  .frame-nav button {
    padding: 6px 10px;
    font-size: 12px;
  }
  .frame-info {
    text-align: center;
    font-size: 14px;
    color: var(--neon-blue);
    margin: 6px 0;
  }
  .filter-controls {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .filter-controls button {
    margin: 0;
    width: 100%;
    padding: 6px;
    font-size: 12px;
  }
  .modal {
    display: none;
    position: fixed;
    z-index: 2000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    overflow-y: auto;
  }
  .modal-content {
    background-color: var(--panel);
    margin: 10% auto;
    padding: 15px;
    border: 1px solid var(--neon-blue);
    width: 90%;
    max-width: 400px;
    border-radius: 6px;
    box-shadow: 0 0 10px var(--neon-blue);
  }
  .close {
    color: #aaa;
    float: right;
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
  }
  .close:hover {
    color: var(--neon-red);
  }
  .modal-title {
    color: var(--neon-blue);
    text-shadow: 0 0 4px var(--neon-blue);
    margin-bottom: 15px;
    font-size: 18px;
    text-align: center;
  }
  .modal-group {
    margin-bottom: 10px;
  }
  #all-frames-modal {
    display: none;
    position: fixed;
    z-index: 3000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.9);
    overflow-y: auto;
  }
  #all-frames-content {
    background-color: var(--panel);
    margin: 4% auto;
    padding: 15px;
    border: 1px solid var(--neon-blue);
    width: 95%;
    max-width: 1200px;
    border-radius: 6px;
    box-shadow: 0 0 15px var(--neon-blue);
  }
  #all-frames-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 6px;
    padding: 6px;
  }
  .frame-thumbnail {
    border: 1px solid var(--neon-green);
    cursor: pointer;
    transition: transform 0.2s;
  }
  .frame-thumbnail:hover {
    transform: scale(1.03);
    box-shadow: 0 0 6px var(--neon-green);
  }
  .frame-thumbnail img {
    width: 100%;
    height: auto;
    display: block;
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
  }
  .frame-number {
    text-align: center;
    color: var(--neon-blue);
    font-size: 12px;
    margin-top: 3px;
  }
  footer {
    padding:4px 6px;
    font-size:10px;
    color:var(--neon-green);
    text-align:center;
    background:transparent;
    text-shadow: 0 0 2px var(--neon-green);
    position: fixed;
    bottom: 0;
    width: 100%;
    z-index: 10;
    display: none;
  }
  .webcam-settings-panel {
    background: var(--panel);
    border: 1px solid var(--neon-purple);
    border-radius: 4px;
    padding: 8px;
    margin-top: 8px;
    box-shadow: 0 0 8px var(--neon-purple);
    display: none;
  }
  .webcam-settings-panel h4 {
    margin: 0 0 8px 0;
    color: var(--neon-purple);
    text-shadow: 0 0 2px var(--neon-purple);
    font-size: 13px;
  }
  @media (min-width: 768px) {
    body {
      overflow: hidden;
    }
    #main {
      flex-direction: row;
      height: calc(100% - 72px);
    }
    #quadrante-wrapper {
      height: 100%;
    }
    .quadrante {
      min-height: 160px;
      border-radius: 6px;
    }
    #settings-banner {
      display: none;
    }
    #toggle-settings-btn {
      display: none;
    }
    footer {
      display: block;
    }
    #video-frame-content {
      flex-direction: row;
    }
    .filter-controls {
      flex-direction: row;
      flex-wrap: wrap;
    }
  }
  @media (orientation: landscape) {
    header, footer, #fixed-buttons, #toggle-settings-btn {
      display: none;
    }
    #main {
      height: 100%;
      padding: 0;
    }
    #quadrante-wrapper {
      height: 100%;
    }
  }
</style>
</head>
<body>
<div class="metavision-filter"></div>
<header>
  <h1 style="margin:0;font-size:16px">MetaVisium Researcher</h1>
  <div style="font-size:11px;color:var(--neon-green)">Created by Domenico Pizzurro Researcher</div>
</header>
<div id="fixed-buttons">
  <button class="fullscreen-btn">Schermo Intero</button>
  <button class="exit-fullscreen-btn">Esci Schermo Intero</button>
  <button class="video-frame-btn">Video Frame</button>
</div>
<div id="main">
  <div id="quadrante-wrapper">
    <div class="quadrante" id="quad1">
      <canvas></canvas>
      <video autoplay muted playsinline style="display:none;"></video>
      <div class="monitor-spento">MONITOR SPENTO</div>
    </div>
  </div>
  <div id="settings-banner"></div>
</div>
<div id="webcamModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <h2 class="modal-title">Configurazione Videocamera</h2>
    <div class="modal-group">
      <label for="webcamDevice">Dispositivo:</label>
      <select id="webcamDevice" class="tipo-noise"></select>
    </div>
    <div class="modal-group">
      <label for="webcamResolution">Risoluzione:</label>
      <select id="webcamResolution" class="tipo-noise">
        <option value="320x240">320x240 (QVGA)</option>
        <option value="640x480">640x480 (VGA)</option>
        <option value="1280x720">1280x720 (HD)</option>
        <option value="1920x1080" selected>1920x1080 (Full HD)</option>
      </select>
    </div>
    <div class="modal-group">
      <label for="webcamFps">Frame Rate (FPS):</label>
      <input type="range" id="webcamFps" min="1" max="60" value="30">
      <span id="fpsValue">30 FPS</span>
    </div>
    <div class="row" style="margin-top: 15px;">
      <button id="confirmWebcam" class="small">Conferma</button>
      <button id="cancelWebcam" class="small">Annulla</button>
    </div>
  </div>
</div>
<footer>MetaVisione - Created By Domenico Pizzurro</footer>
<button id="toggle-settings-btn">⚙️ Impostazioni</button>
<div id="video-frame-page">
 <div id="video-frame-header">
    <button id="back-to-main" class="small">Torna a MetaVisium</button>
    <div style="display: flex; flex-direction: column; align-items: center; gap: 3px;">
        <h2 id="video-frame-title">Analisi Fotogrammi Video</h2>
        <div id="video-frame-subtitle">Created By Domenico Pizzurro Researcher</div>
    </div>
</div>
    <div id="video-frame-content">
        <div id="video-frame-canvas-container">
            <canvas id="video-frame-canvas"></canvas>
        </div>
<div id="video-frame-controls">
<div class="file-input-container">
    <label for="videoFileInput" class="cyberpunk-file-label">Carica Video</label>
    <input type="file" id="videoFileInput" accept="video/*" />
</div>
  <label for="extractionFps" style="color: var(--neon-blue); text-shadow: 0 0 4px var(--neon-blue), 0 0 8px var(--neon-blue); font-family: 'Courier New', monospace; font-weight: bold; font-size: 12px;">FPS Estrazione:</label>
  <select id="extractionFps" style="font-family: 'Courier New', monospace; font-size: 12px; color: var(--neon-green); background: transparent; border: 2px solid var(--neon-green); border-radius: 6px; padding: 6px 10px; min-width: 120px; box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);">
    <option value="1">1 FPS</option>
    <option value="2">2 FPS</option>
    <option value="5">5 FPS</option>
    <option value="10" selected>10 FPS</option>
    <option value="15">15 FPS</option>
    <option value="30">30 FPS</option>
  </select>
</div>
    <button id="create-frames-btn" class="cyberpunk-btn">🔍 Crea Fotogrammi</button>
    <button id="cancel-frames-btn" class="cyberpunk-btn small" style="display: none;">🚫 Annulla Fotogrammi</button>
    <div class="frame-info" id="frameInfo">Frame 0 / 0</div>
    <div class="frame-nav">
        <button id="prevFrame" class="cyberpunk-btn">⏮️ Indietro</button>
        <button id="nextFrame" class="cyberpunk-btn">Avanti ⏭️</button>
    </div>
    <div class="filter-controls">
        <button id="applyNegative" class="cyberpunk-btn">🌑 Negativo</button>
        <button id="applyGrayscale" class="cyberpunk-btn">🖤 Scala Grigi</button>
        <button id="applyUV" class="cyberpunk-btn">🔮 Filtro UV</button>
        <button id="applyMirror" class="cyberpunk-btn">🪞 Specchio</button>
        <button id="resetFilters" class="cyberpunk-btn">🔄 Reset Filtri</button>
    </div>
    <button id="viewAllFrames" class="cyberpunk-btn small">🖼️ Mostra Primi 50 Fotogrammi</button>
    <button id="saveFrame" class="cyberpunk-btn small">💾 Salva Fotogramma</button>
</div>
    </div>
</div>
<div id="all-frames-modal" class="modal">
  <div id="all-frames-content">
    <span class="close" id="closeAllFrames">&times;</span>
    <h2>Tutti i Fotogrammi</h2>
    <div id="all-frames-grid"></div>
  </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
  let webcamStream = null;
  let webcamPermissionDenied = false;
  let currentWebcamSettings = {
    deviceId: '',
    resolution: '1920x1080',
    fps: 30
  };
  let hasRequestedWebcamPermission = false;
  const webcamModal = document.getElementById('webcamModal');
  const closeModal = document.querySelector('.close');
  const confirmWebcamBtn = document.getElementById('confirmWebcam');
  const cancelWebcamBtn = document.getElementById('cancelWebcam');
  const webcamDeviceSelect = document.getElementById('webcamDevice');
  const webcamResolutionSelect = document.getElementById('webcamResolution');
  const webcamFpsSlider = document.getElementById('webcamFps');
  const fpsValue = document.getElementById('fpsValue');
  let currentQuadrant = null;
  webcamFpsSlider.addEventListener('input', function() {
    fpsValue.textContent = this.value + ' FPS';
    currentWebcamSettings.fps = parseInt(this.value);
  });
  closeModal.addEventListener('click', function() {
    webcamModal.style.display = 'none';
  });
  cancelWebcamBtn.addEventListener('click', function() {
    webcamModal.style.display = 'none';
  });
  webcamDeviceSelect.addEventListener('change', function() {
    currentWebcamSettings.deviceId = this.value;
  });
  confirmWebcamBtn.addEventListener('click', async function() {
    if (currentQuadrant) {
      await setupWebcam(currentQuadrant);
    }
    webcamModal.style.display = 'none';
  });
  async function getWebcamDevices() {
    try {
      if (!hasRequestedWebcamPermission) {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        stream.getTracks().forEach(track => track.stop());
        hasRequestedWebcamPermission = true;
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      webcamDeviceSelect.innerHTML = '';
      if (videoDevices.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.text = "Nessuna videocamera rilevata";
        webcamDeviceSelect.appendChild(option);
      } else {
        videoDevices.forEach((device, index) => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.text = device.label || `Videocamera ${index + 1}`;
          webcamDeviceSelect.appendChild(option);
        });
        currentWebcamSettings.deviceId = videoDevices[0].deviceId;
      }
    } catch (err) {
      console.error('Errore enumerazione dispositivi:', err);
      alert("Impossibile accedere alla videocamera. Assicurati di aver concesso i permessi.");
    }
  }
  async function setupWebcam(q) {
    try {
      const resolution = currentWebcamSettings.resolution.split('x');
      const width = parseInt(resolution[0]);
      const height = parseInt(resolution[1]);
      let constraints = {
        video: {
          deviceId: currentWebcamSettings.deviceId ? { exact: currentWebcamSettings.deviceId } : undefined,
          width: { ideal: width },
          height: { ideal: height },
          frameRate: { ideal: currentWebcamSettings.fps }
        },
        audio: false
      };
      if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
      }
      webcamStream = await navigator.mediaDevices.getUserMedia(constraints);
      q.video.srcObject = webcamStream;
      q.canvas.style.display = 'none';
      q.video.style.display = 'block';
      applyVideoFilters(q);
    } catch (err) {
      console.warn("Primo tentativo fallito con vincoli ideali. Tentativo di fallback...", err);
      try {
        let fallbackConstraints = {
          video: {
            deviceId: currentWebcamSettings.deviceId ? { exact: currentWebcamSettings.deviceId } : undefined
          },
          audio: false
        };
        if (webcamStream) {
          webcamStream.getTracks().forEach(track => track.stop());
        }
        webcamStream = await navigator.mediaDevices.getUserMedia(fallbackConstraints);
        q.video.srcObject = webcamStream;
        q.canvas.style.display = 'none';
        q.video.style.display = 'block';
        applyVideoFilters(q);
        alert("✅ Connessione riuscita!\nLa videocamera è attiva. Potrebbe non supportare la risoluzione o il frame rate selezionati, quindi l'immagine potrebbe apparire con dimensioni diverse.");
      } catch (fallbackErr) {
        console.error("Errore videocamera (anche con fallback):", fallbackErr);
        webcamPermissionDenied = true;
        alert(`❌ Impossibile avviare la videocamera.\nAssicurati che:\n1. Il dispositivo sia connesso e acceso.\n2. Non sia in uso da un'altra applicazione (es. OBS, Zoom, Skype).\n3. I driver siano aggiornati.`);
        q.tipo = q.lastNoiseType || 'plasma';
        q.canvas.style.display = 'block';
        q.video.style.display = 'none';
      }
    }
  }
  function applyVideoFilters(q) {
    const video = q.video;
    if (!video) return;
    let brightness, contrast, saturation, hue, colore;
    if (q.tipo === 'webcam' && q.active) {
      brightness = parseFloat(q.sliderLumWebcam.value) / 128;
      contrast = parseFloat(q.sliderContrastWebcam.value);
      saturation = parseFloat(q.sliderSaturazione.value) / 100;
      hue = parseFloat(q.sliderTonalita.value);
      colore = parseFloat(q.sliderColore.value) / 100;
    } else {
      brightness = parseFloat(q.sliderLum.value) / 128;
      contrast = parseFloat(q.sliderContrast.value);
      saturation = 1;
      hue = 0;
      colore = 1;
    }
    let filterString = '';
    if (q.tipo === 'webcam' && q.active) {
      const finalBrightness = brightness * colore;
      filterString = `brightness(${finalBrightness}) contrast(${contrast}) saturate(${saturation}) hue-rotate(${hue}deg)`;
      video.style.filter = filterString;
      video.style.webkitFilter = filterString;
    } else {
      video.style.filter = '';
      video.style.webkitFilter = '';
    }
  }
  class Perlin {
    constructor(seed){
      this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
      this.p = new Array(256);
      for(let i=0;i<256;i++) this.p[i]=Math.floor(Math.random()*256);
      this.perm = new Array(512);
      for (let i = 0; i < 512; i++) this.perm[i] = this.p[i & 255];
    }
    dot(g,x,y,z){return g[0]*x+g[1]*y+g[2]*z;}
    fade(t){ return t*t*t*(t*(t*6-15)+10); }
    lerp(a,b,t){ return a + t*(b-a); }
    noise(x,y,z=0){
      let X=Math.floor(x)&255, Y=Math.floor(y)&255, Z=Math.floor(z)&255;
      x-=Math.floor(x); y-=Math.floor(y); z-=Math.floor(z);
      let u=this.fade(x), v=this.fade(y), w=this.fade(z);
      let A=this.perm[X]+Y, AA=this.perm[A]+Z, AB=this.perm[A+1]+Z;
      let B=this.perm[X+1]+Y, BA=this.perm[B]+Z, BB=this.perm[B+1]+Z;
      let gAA=this.grad3[this.perm[AA]%12], gBA=this.grad3[this.perm[BA]%12],
          gAB=this.grad3[this.perm[AB]%12], gBB=this.grad3[this.perm[BB]%12],
          gAA1=this.grad3[this.perm[AA+1]%12], gBA1=this.grad3[this.perm[BA+1]%12],
          gAB1=this.grad3[this.perm[AB+1]%12], gBB1=this.grad3[this.perm[BB+1]%12];
      let res = this.lerp(
        this.lerp(
          this.lerp(this.dot(gAA,x,y,z), this.dot(gBA,x-1,y,z), u),
          this.lerp(this.dot(gAB,x,y-1,z), this.dot(gBB,x-1,y-1,z), u),
        v),
        this.lerp(
          this.lerp(this.dot(gAA1,x,y,z-1), this.dot(gBA1,x-1,y,z-1), u),
          this.lerp(this.dot(gAB1,x,y-1,z-1), this.dot(gBB1,x-1,y-1,z-1), u),
        v),
      w);
      return res;
    }
  }
  const perlin = new Perlin();
  function applyGamma(val,g){ return Math.min(255, Math.max(0, Math.pow(val/255, g) * 255 )); }
  function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
  function processPixelRaw(val, q){
    const contrast = parseFloat(q.sliderContrast.value || 1);
    const turb = parseFloat(q.sliderTurb.value || 0);
    const gamma = parseFloat(q.sliderGamma.value || 1);
    const nitidezza = parseFloat(q.sliderNitidezza.value || 1);
    let v = (val - 128) * contrast + 128;
    if(turb > 0){
      v += (Math.random()*2 - 1) * turb;
    }
    v = Math.min(255, Math.max(0, v));
    v = applyGamma(v, gamma);
    if(nitidezza > 1) {
      const sharpFactor = (nitidezza - 1) * 0.5;
      v = v * (1 + sharpFactor);
    }
    if(q.bw){
      const thr = parseInt(q.sliderBWThreshold.value || 128);
      const dither = (q.dither ? (Math.random()*16 - 8) : 0);
      v = (v + dither) > thr ? 255 : 0;
      return v;
    }
    return Math.min(255, Math.max(0, v));
  }
  function resizeCanvasToDisplaySize(canvas){
    const ratio = window.devicePixelRatio || 1;
    let w = Math.max(1, Math.floor(canvas.clientWidth * ratio));
    let h = Math.max(1, Math.floor(canvas.clientHeight * ratio));
    const maxQualitySlider = document.getElementById('maxQualitySlider');
    const isMobile = window.innerWidth < 768;
    const MAX_SIZE = maxQualitySlider ? parseInt(maxQualitySlider.value) : (isMobile ? 300 : 600);
    if (w > MAX_SIZE || h > MAX_SIZE) {
      const scale = MAX_SIZE / Math.max(w, h);
      w = Math.floor(w * scale);
      h = Math.floor(h * scale);
    }
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      return true;
    }
    return false;
  }
  function drawPlasmaClouds(q){
    const ctx = q.ctx; const canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width, h = canvas.height;
    const scale = Math.max(10, parseFloat(q.sliderScala.value));
    const t = performance.now() / 2000 * (parseFloat(q.sliderVel.value)/30);
    const espansione = parseFloat(q.sliderEspansione.value) / 50;
    const img = ctx.createImageData(w,h);
    const reduce = q.pareidolia;
    const lum = parseFloat(q.sliderLum.value) / 128;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const timeFactor = t * 0.7;
        const nx = x/scale + Math.sin(timeFactor * 0.3) * 0.5 * espansione;
        const ny = y/scale + Math.cos(timeFactor * 0.2) * 0.5 * espansione;
        let val = 0;
        if(reduce){
          const samples = [
            perlin.noise((nx-0.1), ny, timeFactor),
            perlin.noise((nx+0.1), ny, timeFactor),
            perlin.noise(nx, (ny-0.1), timeFactor),
            perlin.noise(nx, (ny+0.1), timeFactor),
            perlin.noise(nx, ny, timeFactor)
          ];
          let amp = 1, freq = 1;
          for (let o = 0; o < 4; o++) {
            let sAcc = 0;
            for(let s=0;s<samples.length;s++){
              sAcc += perlin.noise((nx + (s-2)*0.2)/freq, (ny + (s-2)*0.2)/freq, timeFactor*freq);
            }
            val += (sAcc / samples.length) * amp;
            amp *= 0.5; freq *= 2;
          }
        } else {
          let v = 0; let amp = 1, freq = 1;
          for(let o=0;o<4;o++){
            v += perlin.noise(nx*freq, ny*freq, timeFactor*freq) * amp;
            amp *= 0.5; freq *= 2;
          }
          val = v;
        }
        val += 0.3 * Math.sin(x/30 + t*1.5) * Math.cos(y/25 + t*1.2) * espansione;
        let out = Math.floor((val+1) * 128);
        out = out * lum;
        out = Math.min(255, Math.max(0, out));
        out = processPixelRaw(out,q);
        const i = (y*w + x) * 4;
        let [r,g,b] = finalizeRGB(out,out,out,q);
        img.data[i]=r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }
  function drawPlasmaAnim(q){
    const ctx = q.ctx; const canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width, h = canvas.height;
    const scale = Math.max(6, parseFloat(q.sliderScala.value));
    const detail = parseFloat(q.sliderDettagli.value || 1);
    const t = performance.now()/800 * (parseFloat(q.sliderVel.value)/30);
    const espansione = parseFloat(q.sliderEspansione.value) / 50;
    const img = ctx.createImageData(w,h);
    const reduce = q.pareidolia;
    const lum = parseFloat(q.sliderLum.value) / 128;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const timeFactor = t * 1.2;
        const nx = x/(scale*0.8)*detail + Math.sin(timeFactor*0.2)*0.3 * espansione;
        const ny = y / (scale * 1) * detail + Math.cos(timeFactor * 0.3) * 0.3 * espansione;
        let v;
        if(reduce){
          v = (
            perlin.noise((nx-0.1), ny, timeFactor) +
            perlin.noise((nx+0.1), ny, timeFactor) +
            perlin.noise(nx, (ny-0.1), timeFactor) +
            perlin.noise(nx, (ny + 0.1), timeFactor)
          ) / 4 +
          0.5 * (
            perlin.noise(nx*2, ny*2, timeFactor*1.7) +
            perlin.noise((nx+0.2)*2, (ny+0.2)*2, timeFactor*1.7)
          ) / 2;
        } else {
          v = perlin.noise(nx, ny, timeFactor) +
              0.5*perlin.noise(nx*2, ny*2, timeFactor*1.7);
        }
        v += 0.2 * Math.sin(x/20 + timeFactor) * Math.cos(y/18 + timeFactor*0.8) * espansione;
        let val = Math.floor((v+1)*128);
        val = val * lum;
        val = Math.min(255, Math.max(0, val));
        val = processPixelRaw(val,q);
        const i = (y*w + x) * 4;
        let [r,g,b] = finalizeRGB(val,val,val,q);
        img.data[i]=r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }
  function drawSmokeNoise(q){
    const ctx = q.ctx, canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width, h = canvas.height;
    const scale = Math.max(30, parseFloat(q.sliderScala.value)*1.2);
    const t = performance.now()/1000 * (parseFloat(q.sliderVel.value)/30);
    const espansione = parseFloat(q.sliderEspansione.value) / 50;
    const img = ctx.createImageData(w,h);
    const reduce = q.pareidolia;
    const lum = parseFloat(q.sliderLum.value) / 128;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const timeFactor = t * 0.8;
        const nx = x/scale + Math.sin(timeFactor*0.4)*0.4 * espansione;
        const ny = y/scale + Math.cos(timeFactor*0.3)*0.4 * espansione;
        let v = 0, amp=1, freq=1;
        for(let o=0; o<5; o++){
          if(reduce){
            v += amp * (perlin.noise(nx*freq, ny*freq, timeFactor*freq*0.5) +
                       perlin.noise((nx+0.5)*freq, (ny+0.5)*freq, timeFactor*freq*0.5))/2;
          } else {
            v += amp * perlin.noise(nx*freq, ny*freq, timeFactor*freq*0.5);
          }
          amp *= 0.5; freq *= 2;
        }
        v += 0.1 * Math.sin(x/15 + timeFactor*0.7) * (1 - y/h) * espansione;
        let val = Math.floor((v+1) * 128);
        val = val * lum;
        val = Math.min(255, Math.max(0, val));
        val = processPixelRaw(val, q);
        const i = (y*w + x)*4;
        let [r,g,b] = finalizeRGB(val,val,val,q);
        img.data[i]=r;img.data[i+1]=g;img.data[i+2]=b;img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }
  function drawWaterPlasma(q) {
    const ctx = q.ctx;
    const canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width;
    const h = canvas.height;
    const scale = Math.max(90, parseFloat(q.sliderScala.value) * 1.6);
    const t = performance.now() / 1800 * (parseFloat(q.sliderVel.value) / 25);
    const espansione = parseFloat(q.sliderEspansione.value) / 60;
    const img = ctx.createImageData(w, h);
    const lum = parseFloat(q.sliderLum.value) / 110;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const cx = w / 2;
        const cy = h / 2;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx*dx + dy*dy) / 130;
        const angle = Math.atan2(dy, dx) + t * 0.7;
        const radialWave = Math.sin(dist * 4.5 - t * 2.0) * 5 * espansione;
        const circularWave = Math.sin(angle * 2.5 + t * 1.8) * 2 * espansione;
        const nx = (x + radialWave * Math.cos(angle)) / scale;
        const ny = (y + radialWave * Math.sin(angle)) / scale;
        let v = 0;
        let amp = 1;
        let freq = 1;
        for (let o = 0; o < 3; o++) {
          v += amp * perlin.noise(nx * freq, ny * freq, t * freq * 0.6);
          amp *= 0.5;
          freq *= 2;
        }
        v += 0.3 * Math.sin(dist * 2.5 + t * 1.6) * espansione;
        const sparkle = 0.15 * Math.sin(x/12 + y/12 + t*4.5) * Math.sin(t*6.5);
        v += sparkle * espansione;
        let val = Math.floor((v + 0.7) * 110);
        val = val * lum;
        val = Math.min(255, Math.max(0, val));
        val = processPixelRaw(val, q);
        const i = (y * w + x) * 4;
        if (val < 80) {
          img.data[i + 3] = 0;
          continue;
        }
        let depth = (val - 80) / 175;
        let r = 140 * depth;
        let g = 200 * depth + 30;
        let b = 255 * depth + 40;
        r = Math.min(160, r);
        g = Math.min(240, g);
        b = Math.min(255, b);
        const shift = 0.95 + 0.05 * Math.sin(t * 0.4);
        g *= shift;
        b *= shift * 1.05;
        let [fr, fg, fb] = finalizeRGB(r, g, b, q);
        img.data[i] = fr;
        img.data[i + 1] = fg;
        img.data[i + 2] = fb;
        let baseAlpha = 40 + depth * 80;
        if (depth > 0.6) baseAlpha += 50 * Math.max(0, sparkle);
        img.data[i + 3] = Math.min(160, baseAlpha);
      }
    }
    ctx.putImageData(img, 0, 0);
  }
  function drawSmokeSwirl(q){
    const ctx = q.ctx, canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width, h = canvas.height;
    const scale = Math.max(25, parseFloat(q.sliderScala.value));
    const t = performance.now()/1200 * (parseFloat(q.sliderVel.value)/30);
    const espansione = parseFloat(q.sliderEspansione.value) / 50;
    const img = ctx.createImageData(w,h);
    const reduce = q.pareidolia;
    const lum = parseFloat(q.sliderLum.value) / 128;
    for(let y=0;y<h;y++){
      for(let x=0;x<w;x++){
        const centerX = w/2;
        const centerY = h/2;
        const dx = x - centerX;
        const dy = y - centerY;
        const distance = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx);
        const swirlFactor = 0.015 * (parseFloat(q.sliderTurb.value)/50 + 0.5) * espansione;
        const swirlX = x/scale + swirlFactor * distance * Math.cos(angle + t*1.5);
        const swirlY = y/scale + swirlFactor * distance * Math.sin(angle + t*1.8);
        let v = 0, amp=1, freq=1;
        for(let o=0; o<4; o++){
          if(reduce){
            v += amp * (perlin.noise(swirlX*freq, swirlY*freq, t*freq*0.4) +
                       perlin.noise((swirlX+0.7)*freq*2, (swirlY+0.7)*freq*2, t*freq*0.4))/2;
          } else {
            v += amp * perlin.noise(swirlX*freq, swirlY*freq, t*freq*0.4);
          }
          amp *= 0.5; freq *= 2;
        }
        v += 0.1 * Math.sin(distance/20 + t*2) * Math.cos(angle*3 + t) * espansione;
        let val = Math.floor((v+1) * 128);
        val = val * lum;
        val = Math.min(255, Math.max(0, val));
        val = processPixelRaw(val, q);
        const i = (y*w + x)*4;
        let [r,g,b] = finalizeRGB(val,val,val,q);
        img.data[i]=r; img.data[i+1]=g; img.data[i+2]=b; img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }
  function drawSmokeWisps(q){
    const ctx = q.ctx, canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width, h = canvas.height;
    const scale = Math.max(40, parseFloat(q.sliderScala.value)*1.5);
    const t = performance.now()/1800 * (parseFloat(q.sliderVel.value)/30);
    const espansione = parseFloat(q.sliderEspansione.value) / 50;
    const img = ctx.createImageData(w,h);
    const reduce = q.pareidolia;
    const lum = parseFloat(q.sliderLum.value) / 128;
    for(let y=0; y<h; y++){
      for(let x=0; x<w; x++){
        const timeFactor = t * 1.2;
        const wispFactor = 0.3 * (parseFloat(q.sliderTurb.value)/50 + 0.2) * espansione;
        const nx = x/scale + wispFactor * Math.sin(y/25 + timeFactor*0.8);
        const ny = y/scale + wispFactor * Math.cos(x/30 + timeFactor*0.6);
        let v = 0, amp = 1, freq = 1;
        for(let o=0; o<4; o++){
          if(reduce){
            v += amp * (perlin.noise(nx*freq, ny*freq, timeFactor*freq*0.3) +
                        perlin.noise((nx+1.2)*freq*2, (ny+1.2)*freq*2, timeFactor*freq*2))/2;
          } else {
            v += amp * perlin.noise(nx*freq, ny*freq, timeFactor*freq*0.3);
            v += 0.4 * amp * perlin.noise(nx*freq*3, ny*freq*3, timeFactor*freq*0.5);
          }
          amp *= 0.5; freq *= 2;
        }
        v += 0.15 * Math.sin(x/15 + timeFactor) * (1 - y/h) * espansione;
        let val = Math.floor((v+0.8) * 180);
        val = val * lum;
        val = Math.min(255, Math.max(0, val));
        val = processPixelRaw(val, q);
        const i = (y*w + x)*4;
        let [r,g,b] = finalizeRGB(val, val, val, q);
        img.data[i] = r;
        img.data[i+1] = g;
        img.data[i+2] = b;
        img.data[i+3] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
  }
  function drawFirePlasma(q){
    const ctx = q.ctx, canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width, h = canvas.height;
    const speed = parseFloat(q.sliderVel.value || 30) / 15;
    const scale = Math.max(30, parseFloat(q.sliderScala.value || 60));
    const lum = Math.max(0.01, parseFloat(q.sliderLum.value || 128) / 128);
    const contrast = parseFloat(q.sliderContrast.value || 1);
    const turb = parseFloat(q.sliderTurb.value || 0) / 50;
    const espansione = parseFloat(q.sliderEspansione.value || 0) / 50;
    const t = performance.now() / 1000 * speed;
    const invScale = 1 / scale;
    const img = ctx.createImageData(w,h);
    const data = img.data;
    for(let i=0; i<w*h; i++){
      let base = 128 + (Math.random()*50 - 25);
      if(Math.random() < 0.02 + turb * 0.1) base = 255;
      else if(Math.random() < 0.02 + turb * 0.1) base = 0;
      base = ((base - 128) * contrast) + 128;
      base = Math.max(0, Math.min(255, base * lum));
      const idx = i*4;
      data[idx] = base;
      data[idx+1] = base;
      data[idx+2] = base;
      data[idx+3] = 255;
    }
    for(let y=0; y<h; y++){
      for(let x=0; x<w; x++){
        const idx = (y*w+x)*4;
        const timeFactor = t * 0.7;
        const nx = x * invScale + Math.sin(timeFactor * 0.3) * 0.4 * espansione;
        const ny = y * invScale + Math.cos(timeFactor * 0.2) * 0.4 * espansione;
        let v = 0, amp=1, freq=1;
        for(let o=0; o<4; o++){
          v += amp * perlin.noise(nx*freq, ny*freq, timeFactor*freq*0.5);
          amp *= 0.5; freq *= 2;
        }
        let smokeVal = ((v + 1) * 128 - 128) * contrast + 128;
        smokeVal = smokeVal * lum;
        if(turb > 0) {
          smokeVal += (Math.random()*2 - 1) * turb * 100;
        }
        smokeVal = Math.min(255, Math.max(0, smokeVal));
        const alpha = Math.floor(30 + 70 * lum);
        let [r, g, b] = finalizeRGB(smokeVal, smokeVal, smokeVal, q);
        data[idx]   = (data[idx]*(255-alpha) + r*alpha)/255;
        data[idx+1] = (data[idx+1]*(255-alpha) + g*alpha)/255;
        data[idx+2] = (data[idx+2]*(255-alpha) + b*alpha)/255;
        data[idx+3] = 255;
      }
    }
    ctx.putImageData(img,0,0);
  }
  function drawLiquidPlasma(q) {
    const ctx = q.ctx;
    const canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width;
    const h = canvas.height;
    const scale = Math.max(40, parseFloat(q.sliderScala.value) * 0.8);
    const t = performance.now() / 1500 * (parseFloat(q.sliderVel.value) / 25);
    const espansione = parseFloat(q.sliderEspansione.value) / 40;
    const lum = parseFloat(q.sliderLum.value) / 128;
    const img = ctx.createImageData(w, h);
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        const timeFactor = t * 0.9;
        const nx = x / scale + Math.sin(timeFactor * 0.3) * 0.4 * espansione;
        const ny = y / scale + Math.cos(timeFactor * 0.2) * 0.4 * espansione;
        let v = 0;
        let amp = 1;
        let freq = 1;
        for (let o = 0; o < 3; o++) {
          v += amp * perlin.noise(nx * freq, ny * freq, timeFactor * freq * 0.6);
          amp *= 0.5;
          freq *= 2;
        }
        const cx = w / 2;
        const cy = h / 2;
        const dx = x - cx;
        const dy = y - cy;
        const dist = Math.sqrt(dx * dx + dy * dy) / 80;
        const wave = Math.sin(dist * 3 - t * 1.2) * 0.3;
        v += wave;
        let val = Math.floor((v + 1) * 128);
        val = val * lum;
        val = Math.min(255, Math.max(0, val));
        val = processPixelRaw(val, q);
        const gray = Math.floor(val);
        const r = gray;
        const g = gray;
        const b = gray;
        const [fr, fg, fb] = finalizeRGB(r, g, b, q);
        const i = (y * w + x) * 4;
        img.data[i] = fr;
        img.data[i + 1] = fg;
        img.data[i + 2] = fb;
        img.data[i + 3] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
  }
  function drawNebulaNoise(q){
    const ctx = q.ctx, canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w=canvas.width, h=canvas.height;
    const t = performance.now()/2500 * (parseFloat(q.sliderVel.value)/30);
    const espansione = parseFloat(q.sliderEspansione.value) / 50;
    const img = ctx.createImageData(w,h);
    const scale = Math.max(35, parseFloat(q.sliderScala.value));
    const reduce = q.pareidolia;
    const lum = parseFloat(q.sliderLum.value) / 128;
    for(let y=0;y<h;y++){
      for(let x = 0; x < w; x++){
        const timeFactor = t * 0.9;
        const nx = x/scale + Math.sin(timeFactor*0.3)*0.4 * espansione;
        const ny = y/scale + Math.cos(timeFactor*0.2)*0.4 * espansione;
        let v;
        if(reduce){
          v = (perlin.noise(nx, ny, timeFactor) + perlin.noise((nx+0.1), (ny+0.1), timeFactor))/2
              * 0.9 + 0.5*perlin.noise(nx*2, ny*2, timeFactor*1.5);
        } else {
          v = perlin.noise(nx, ny, timeFactor) * 0.9 + 0.5*perlin.noise(nx*2, ny*2, timeFactor*1.5);
        }
        v += 0.1 * Math.sin(x/28 + timeFactor) * Math.cos(y/25 + timeFactor*0.6) * espansione;
        let base = Math.floor((v+1)*128);
        base = base * lum;
        base = Math.min(255, Math.max(0, base));
        let r = processPixelRaw(Math.floor(base * 0.9), q);
        let g = processPixelRaw(Math.floor(base * 1.0), q);
        let b = processPixelRaw(Math.floor(base * 1.2), q);
        const i=(y*w+x)*4;
        let [fr,fg,fb] = finalizeRGB(r,g,b,q);
        img.data[i]=fr; img.data[i+1]=fg; img.data[i+2]=fb; img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }
  function drawStaticDrift(q) {
    const ctx = q.ctx;
    const canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width;
    const h = canvas.height;
    const lum = parseFloat(q.sliderLum.value);
    const drift = parseFloat(q.sliderVel.value) / 100;
    const t = performance.now() / 1000;
    const blockMin = 1;
    const blockMax = Math.max(2, Math.round(lum / 20));
    const img = ctx.createImageData(w, h);
    const xOffset = Math.floor(Math.sin(t * 2) * 3 * drift);
    const yOffset = Math.floor(Math.cos(t * 1.5) * 2 * drift);
    for (let y = 0; y < h; y += blockMin) {
      for (let x = 0; x < w; x += blockMin) {
        if (Math.random() < 0.5) {
          let v = Math.floor(Math.random() * lum * (0.7 + 0.3 * Math.random()));
          v = processPixelRaw(v, q);
          let [r, g, b] = finalizeRGB(v, v, v, q);
          const block = blockMin + Math.floor(Math.random() * (blockMax - blockMin + 1));
          for (let yy = 0; yy < block; yy++) {
            for (let xx = 0; xx < block; xx++) {
              const px = (x + xx + xOffset + w) % w;
              const py = (y + yy + yOffset + h) % h;
              const i = (py * w + px) * 4;
              img.data[i] = r;
              img.data[i + 1] = g;
              img.data[i + 2] = b;
              img.data[i + 3] = 255;
            }
          }
        }
      }
    }
    ctx.putImageData(img, 0, 0);
  }
  function drawBadtv(q) {
    const ctx = q.ctx;
    const canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width;
    const h = canvas.height;
    const t = performance.now() / 1000;
    const lum = parseFloat(q.sliderLum.value) / 255;
    const vel = parseFloat(q.sliderVel.value);
    const turb = parseFloat(q.sliderTurb.value) / 100;
    const gamma = Math.max(0.1, parseFloat(q.sliderGamma.value) / 100);
    const uv = parseFloat(q.sliderUV.value);
    const contrast = parseFloat(q.sliderContrast.value);
    const scale = Math.max(1, parseInt(q.sliderScala.value));
    const baseContrast = 3.0;
    const finalContrast = baseContrast * Math.max(0.1, contrast);
    const scanOffset = (t * vel * 30) % h;
    const waveX = Math.sin(t * 0.5) * 0.3;
    const waveY = Math.sin(t * 0.7) * 0.2;
    const img = ctx.createImageData(w, h);
    const data = img.data;
    for (let y = 0; y < h; y++) {
      const yOffset = Math.floor(
        Math.sin(y * 0.1 + t * vel) * uv +
        (Math.sin(y * 0.07 + t * 2.1) - 0.5) * uv +
        (Math.random() - 0.5) * uv * 4
      );
      const scanDarken = 0.6 + 0.4 * Math.sin((y - scanOffset) * 0.2);
      for (let x = 0; x < w; x++) {
        const i = ((y + yOffset) * w + x) * 4;
        if (i >= data.length) continue;
        let noise = Math.random();
        const phaseX = (x * 0.02 + t * vel * 0.8) % (2 * Math.PI);
        const phaseY = (y * 0.01 + t * vel * 0.5) % (2 * Math.PI);
        const wave = (
          Math.sin(phaseX + waveX) * 0.3 +
          Math.sin(phaseY + waveY) * 0.2 +
          Math.sin(phaseX + phaseY + t * 0.3) * 0.1
        ) * 0.5 + 0.5;
        noise *= wave;
        if (Math.random() < turb) {
          noise = Math.random();
        }
        noise *= scanDarken;
        const r = noise * 0.8 + Math.random() * 0.2;
        const g = noise * 0.7 + Math.random() * 0.3;
        const b = noise * 0.6 + Math.random() * 0.4;
        const applyContrast = (val) => (val - 0.5) * finalContrast + 0.5;
        const rC = Math.max(0, Math.min(1, applyContrast(r)));
        const gC = Math.max(0, Math.min(1, applyContrast(g)));
        const bC = Math.max(0, Math.min(1, applyContrast(b)));
        const rG = Math.pow(rC, gamma);
        const gG = Math.pow(gC, gamma);
        const bG = Math.pow(bC, gamma);
        const rVal = Math.floor(rG * 255 * lum);
        const gVal = Math.floor(gG * 255 * lum);
        const bVal = Math.floor(bG * 255 * lum);
        data[i]     = rVal;
        data[i + 1] = gVal;
        data[i + 2] = bVal;
        data[i + 3] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
  }
  function drawTuboCatodico(q) {
    const ctx = q.ctx;
    const canvas = q.canvas;
    resizeCanvasToDisplaySize(canvas);
    const w = canvas.width;
    const h = canvas.height;
    const img = ctx.createImageData(w, h);
    const lum = parseFloat(q.sliderLum.value);
    const density = parseFloat(q.sliderDettagli.value) / 10;
    const time = performance.now() / 1000;
    for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x++) {
        let randomNoise = Math.floor(Math.random() * 256);
        if (Math.random() > density) randomNoise = 0;
        const flicker = 0.8 + 0.2 * Math.sin(time * 10 + y / 5);
        let v = randomNoise * (lum / 255) * flicker;
        v = processPixelRaw(v, q);
        let [r, g, b] = finalizeRGB(v, v, v, q);
        const i = (y * w + x) * 4;
        img.data[i] = r;
        img.data[i + 1] = g;
        img.data[i + 2] = b;
        img.data[i + 3] = 255;
      }
    }
    ctx.putImageData(img, 0, 0);
  }
  function finalizeRGB(r,g,b, q){
    const uvIntensity = parseFloat(q.sliderUV.value || 0);
    if(uvIntensity > 0) {
      const uvEffect = uvIntensity / 100;
      r = Math.max(0, r * (1 - uvEffect * 0.7));
      g = Math.max(0, g * (1 - uvEffect * 0.3));
      b = Math.min(255, b * (1 + uvEffect));
    }
    let hsl = rgbToHsl(r, g, b);
    const saturazione = parseFloat(q.sliderSaturazione.value) / 100;
    hsl[1] = Math.max(0, Math.min(1, hsl[1] * saturazione));
    const tonalita = parseFloat(q.sliderTonalita.value);
    hsl[0] = ((hsl[0] * 360 + tonalita) % 360 + 360) % 360 / 360;
    const colore = parseFloat(q.sliderColore.value) / 100;
    if (colore < 1) {
      hsl[1] = hsl[1] * colore;
      hsl[2] = hsl[2] * colore;
    } else {
      hsl[2] = Math.min(1, hsl[2] + (colore - 1) * 0.5);
    }
    let newRgb = hslToRgb(hsl[0], hsl[1], hsl[2]);
    r = newRgb[0];
    g = newRgb[1];
    b = newRgb[2];
    if(q.grayscale){
      const L = Math.round(luminance(r,g,b));
      r = g = b = L;
    }
    const lum = luminance(r,g,b) || 1;
    const proc = processPixelRaw(lum, q);
    const scale = proc / lum;
    r = Math.min(255, Math.max(0, Math.round(r * scale)));
    g = Math.min(255, Math.max(0, Math.round(g * scale)));
    b = Math.min(255, Math.max(0, Math.round(b * scale)));
    if(q.invert){
      r = 255 - r; g = 255 - g; b = 255 - b;
    }
    return [r,g,b];
  }
  function rgbToHsl(r, g, b){
    r /= 255, g /= 255, b /= 255;
    let max = Math.max(r, g, b), min = Math.min(r, g, b);
    let h, s, l = (max + min) / 2;
    if(max == min){
      h = s = 0;
    }else{
      let d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      switch(max){
        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
        case g: h = (b - r) / d + 2; break;
        case b: h = (r - g) / d + 4; break;
      }
      h /= 6;
    }
    return [h, s, l];
  }
  function hslToRgb(h, s, l){
    let r, g, b;
    if(s == 0){
      r = g = b = l;
    }else{
      const hue2rgb = (p, q, t) => {
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }
      let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      let p = 2 * l - q;
      r = hue2rgb(p, q, h + 1/3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1/3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  }
  const settingsBanner = document.getElementById('settings-banner');
  const qualityDiv = document.createElement('div');
  qualityDiv.innerHTML = `
    <div class="quadrante-settings" style="background: #1a1a2e; padding: 8px; border-radius: 6px; margin-bottom: 12px; border: 1px solid #0a0a1a; box-shadow: 0 0 6px rgba(0, 150, 255, 0.3);">
      <h3 style="margin:0 0 8px 0; color: #fff; text-shadow: 0 0 2px rgba(0, 150, 255, 0.5);">⚙️ Regola Qualità Monitor</h3>
      <div class="slider-group">
        <label style="color: #a0e0ff; font-weight: bold;">Dimensione (px)</label>
        <input type="range" id="maxQualitySlider" min="200" max="800" value="300" step="50" />
        <span id="maxQualityValue" class="value-display" style="color: #ffcc00; font-weight: bold;">300</span>
      </div>
      <div class="note" style="color: #aaa; font-size: 10px; margin-top: 4px;">
        Riduci per più fluidità, aumenta per più nitidezza. (Dipende della potenza del tuo Smartphone)
      </div>
    </div>
  `;
  settingsBanner.appendChild(qualityDiv);
  const maxQualitySlider = document.getElementById('maxQualitySlider');
  const maxQualityValue = document.getElementById('maxQualityValue');
  maxQualitySlider.addEventListener('input', function() {
    maxQualityValue.textContent = this.value;
  });
  const quadranti = [];
  const noiseOptionsHTML = `
    <option value="plasma">Plasma</option>
    <option value="plasmaAnim">Plasma Animato</option>
    <option value="smoke">Smoke Noise</option>
    <option value="smokeswirl">Smoke Swirl</option>
    <option value="smokewisp">Smoke Wisps</option>
    <option value="waterplasma">Water Noise</option>
    <option value="liquid">Liquid Plasma</option>
    <option value="fire">Smoke + White Noise</option>
    <option value="nebula">Nebula Noise</option>
    <option value="staticdrift">Static Drift</option>
    <option value="tubocatodico">Tubo Catodico</option>
    <option value="badtv">Noise New Tv (In fase Di Sperimentazione)</option>
  `;
  const div = document.createElement('div');
  div.className = 'quadrante-settings';
  div.dataset.quad = 1;
  div.innerHTML = `
    <h3 style="margin:0 0 4px 0; color:var(--neon-pink); text-shadow:0 0 2px var(--neon-pink);">Monitor 1</h3>
    <label>Tipo Noise</label>
    <select class="tipo-noise">${noiseOptionsHTML}</select>
    <div class="slider-group" style="margin-top: 10px;">
      <label>Luminosità (50-255)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">150</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Velocità (10-60)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">30</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Espansione Movimento (0-100)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">0</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Contrasto (0.5-3)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">0.9</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Granulato (0-50)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">0</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Gamma (0.1-3)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">1.0</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Scala (20-200)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">100</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Dettagli (1-10)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">1.0</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Nitidezza (1-3)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">1.0</span>
      </div>
    </div>
    <div class="slider-group">
      <label>Filtro UV (0-100)</label>
      <div class="custom-slider-container">
        <div class="custom-slider">
          <div class="custom-slider-track"></div>
          <div class="custom-slider-thumb"></div>
        </div>
        <span class="value-display">0</span>
      </div>
    </div>
    <div class="button-group row" style="margin-top:8px">
      <button class="small record-btn">Registra</button>
      <button class="small grayscale">Scala Grigi</button>
      <button class="small pareidolia">Riduci Pareidolia</button>
      <button class="small invert">Invert</button>
      <button class="small webcam-toggle">Attiva Videocamera</button>
      <button class="small webcam-settings-btn" style="display: none;">Setting</button>
    </div>
    <div class="webcam-settings-panel">
      <h4>Impostazioni Videocamera</h4>
      <div class="slider-group"><label>Luminosità (50-255)</label><div class="custom-slider-container"><div class="custom-slider"><div class="custom-slider-track"></div><div class="custom-slider-thumb"></div></div><span class="value-display">100</span></div></div>
      <div class="slider-group"><label>Contrasto (0.5-3)</label><div class="custom-slider-container"><div class="custom-slider"><div class="custom-slider-track"></div><div class="custom-slider-thumb"></div></div><span class="value-display">1.0</span></div></div>
      <div class="slider-group"><label>Saturazione (0-200)</label><div class="custom-slider-container"><div class="custom-slider"><div class="custom-slider-track"></div><div class="custom-slider-thumb"></div></div><span class="value-display">100</span></div></div>
      <div class="slider-group"><label>Tonalità (-180-180)</label><div class="custom-slider-container"><div class="custom-slider"><div class="custom-slider-track"></div><div class="custom-slider-thumb"></div></div><span class="value-display">0</span></div></div>
      <div class="slider-group"><label>Colore (0-200)</label><div class="custom-slider-container"><div class="custom-slider"><div class="custom-slider-track"></div><div class="custom-slider-thumb"></div></div><span class="value-display">100</span></div></div>
    </div>
    <div class="note" style="font-size: 9px; margin-top: 6px;">Usa la videocamera per riprendere il noise del monitor e Registralo.</div>
  `;
  settingsBanner.appendChild(div);
  const quadEl = document.getElementById('quad1');
  const canvas = quadEl.querySelector('canvas');
  const ctx = canvas.getContext('2d');
  const video = quadEl.querySelector('video');
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  resizeCanvasToDisplaySize(canvas);
  const qobj = {
    el: quadEl, canvas, ctx, video,
    active: true,
    tipo: 'plasma',
    lastNoiseType: 'plasma',
    grayscale: false,
    bw: false,
    pareidolia: false,
    invert: false,
    dither: true,
    sliderLum: null,
    sliderVel: null,
    sliderEspansione: null,
    sliderContrast: null,
    sliderTurb: null,
    sliderGamma: null,
    sliderScala: null,
    sliderDettagli: null,
    sliderNitidezza: null,
    sliderUV: null,
    sliderLumWebcam: null,
    sliderContrastWebcam: null,
    sliderSaturazione: null,
    sliderTonalita: null,
    sliderColore: null,
    recorder: null, recordedChunks: [], recording: false
  };
  quadranti.push(qobj);
  const sel = div.querySelector('.tipo-noise');
  sel.addEventListener('change', async (e) => {
    qobj.tipo = e.target.value;
    qobj.lastNoiseType = e.target.value;
  });
  const webcamToggleBtn = div.querySelector('.webcam-toggle');
  const webcamSettingsBtn = div.querySelector('.webcam-settings-btn');
  webcamToggleBtn.addEventListener('click', async function() {
    if (qobj.tipo === 'webcam') {
      qobj.tipo = qobj.lastNoiseType;
      qobj.canvas.style.display = 'block';
      qobj.video.style.display = 'none';
      this.textContent = 'Attiva Videocamera';
      this.classList.remove('active');
      webcamSettingsBtn.style.display = 'none';
      const webcamSettingsPanel = div.querySelector('.webcam-settings-panel');
      webcamSettingsPanel.style.display = 'none';
    } else {
      qobj.lastNoiseType = qobj.tipo;
      qobj.tipo = 'webcam';
      currentQuadrant = qobj;
      await getWebcamDevices();
      webcamModal.style.display = 'block';
      this.textContent = 'Disattiva Videocamera';
      this.classList.add('active');
      webcamSettingsBtn.style.display = 'inline-block';
    }
  });
  webcamSettingsBtn.addEventListener('click', function() {
    const webcamSettingsPanel = div.querySelector('.webcam-settings-panel');
    if (webcamSettingsPanel.style.display === 'block') {
      webcamSettingsPanel.style.display = 'none';
    } else {
      webcamSettingsPanel.style.display = 'block';
    }
  });
  function createCustomSlider(container, min, max, step, initialValue, onChangeCallback) {
    const sliderTrack = container.querySelector('.custom-slider-track');
    const sliderThumb = container.querySelector('.custom-slider-thumb');
    const valueDisplay = container.querySelector('.value-display');
    let isDragging = false;
    let currentValue = initialValue;
    function updateSliderPosition() {
      const percent = (currentValue - min) / (max - min);
      sliderThumb.style.left = `calc(${percent * 100}% - 9px)`;
      sliderTrack.style.width = `${percent * 100}%`;
      valueDisplay.textContent = step && step.toString().includes('.') ? parseFloat(currentValue).toFixed(1) : currentValue;
    }
    updateSliderPosition();
    sliderThumb.addEventListener('mousedown', startDrag);
    sliderThumb.addEventListener('touchstart', startDrag, { passive: false });
    function startDrag(e) {
      isDragging = true;
      e.preventDefault();
      document.addEventListener('mousemove', moveThumb);
      document.addEventListener('touchmove', moveThumb, { passive: false });
      document.addEventListener('mouseup', stopDrag);
      document.addEventListener('touchend', stopDrag);
    }
    function moveThumb(e) {
      if (!isDragging) return;
      e.preventDefault();
      const sliderRect = sliderTrack.parentElement.getBoundingClientRect();
      let clientX;
      if (e.type === 'touchmove') {
        clientX = e.touches[0].clientX;
      } else {
        clientX = e.clientX;
      }
      let percent = (clientX - sliderRect.left) / sliderRect.width;
      percent = Math.max(0, Math.min(1, percent));
      let newValue = min + percent * (max - min);
      newValue = Math.round(newValue / step) * step;
      newValue = Math.max(min, Math.min(max, newValue));
      if (newValue !== currentValue) {
        currentValue = newValue;
        updateSliderPosition();
        if (onChangeCallback) {
          onChangeCallback(currentValue);
        }
      }
    }
    function stopDrag() {
      isDragging = false;
      document.removeEventListener('mousemove', moveThumb);
      document.removeEventListener('touchmove', moveThumb);
      document.removeEventListener('mouseup', stopDrag);
      document.removeEventListener('touchend', stopDrag);
    }
    return {
      get value() {
        return currentValue;
      }
    };
  }
  const sliderConfigs = [
    { selector: '.slider-group:nth-child(4) .custom-slider-container', min: 50, max: 255, step: 1, initial: 150, prop: 'sliderLum' },
    { selector: '.slider-group:nth-child(5) .custom-slider-container', min: 10, max: 60, step: 1, initial: 30, prop: 'sliderVel' },
    { selector: '.slider-group:nth-child(6) .custom-slider-container', min: 0, max: 100, step: 1, initial: 0, prop: 'sliderEspansione' },
    { selector: '.slider-group:nth-child(7) .custom-slider-container', min: 0.5, max: 3, step: 0.1, initial: 0.9, prop: 'sliderContrast' },
    { selector: '.slider-group:nth-child(8) .custom-slider-container', min: 0, max: 50, step: 1, initial: 0, prop: 'sliderTurb' },
    { selector: '.slider-group:nth-child(9) .custom-slider-container', min: 0.1, max: 3, step: 0.1, initial: 1, prop: 'sliderGamma' },
    { selector: '.slider-group:nth-child(10) .custom-slider-container', min: 20, max: 200, step: 1, initial: 100, prop: 'sliderScala' },
    { selector: '.slider-group:nth-child(11) .custom-slider-container', min: 1, max: 10, step: 0.1, initial: 1, prop: 'sliderDettagli' },
    { selector: '.slider-group:nth-child(12) .custom-slider-container', min: 1, max: 3, step: 0.1, initial: 1, prop: 'sliderNitidezza' },
    { selector: '.slider-group:nth-child(13) .custom-slider-container', min: 0, max: 100, step: 1, initial: 0, prop: 'sliderUV' },
    { selector: '.webcam-settings-panel .slider-group:nth-child(1) .custom-slider-container', min: 50, max: 255, step: 1, initial: 100, prop: 'sliderLumWebcam' },
    { selector: '.webcam-settings-panel .slider-group:nth-child(2) .custom-slider-container', min: 0.5, max: 3, step: 0.1, initial: 1, prop: 'sliderContrastWebcam' },
    { selector: '.webcam-settings-panel .slider-group:nth-child(3) .custom-slider-container', min: 0, max: 200, step: 1, initial: 100, prop: 'sliderSaturazione' },
    { selector: '.webcam-settings-panel .slider-group:nth-child(4) .custom-slider-container', min: -180, max: 180, step: 1, initial: 0, prop: 'sliderTonalita' },
    { selector: '.webcam-settings-panel .slider-group:nth-child(5) .custom-slider-container', min: 0, max: 200, step: 1, initial: 100, prop: 'sliderColore' }
  ];
  sliderConfigs.forEach(config => {
    const container = div.querySelector(config.selector);
    if (container) {
      qobj[config.prop] = createCustomSlider(
        container,
        config.min,
        config.max,
        config.step,
        config.initial,
        (newValue) => {
          if (qobj.tipo === 'webcam') {
            applyVideoFilters(qobj);
          } else {
            if (qobj.active) {
              renderQuadrant(qobj);
            }
          }
        }
      );
    }
  });
  div.querySelector('.grayscale').addEventListener('click', function(){
    qobj.grayscale = !qobj.grayscale;
    this.classList.toggle('active', qobj.grayscale);
  });
  div.querySelector('.pareidolia').addEventListener('click', function(){
    qobj.pareidolia = !qobj.pareidolia;
    this.classList.toggle('active', qobj.pareidolia);
  });
  div.querySelector('.invert').addEventListener('click', function(){
    qobj.invert = !qobj.invert;
    this.classList.toggle('active', qobj.invert);
  });
  div.querySelector('.record-btn').addEventListener('click', function(){
    toggleRecord(qobj, this);
    this.classList.toggle('active', qobj.recording);
  });
  function toggleRecord(q, btnEl){
    if(q.tipo === 'webcam' && q.video && q.video.srcObject){
      if(q.recording){
        q.recorder.stop();
        q.recording = false;
        btnEl.textContent = 'Registra';
      } else {
        try{
          const stream = q.video.srcObject;
          q.recordedChunks = [];
          q.recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp8' });
          q.recorder.ondataavailable = e => { if(e.data && e.data.size) q.recordedChunks.push(e.data); };
          q.recorder.onstop = () => {
            const blob = new Blob(q.recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'Videocamera_monitor.webm'; a.click();
            setTimeout(()=>URL.revokeObjectURL(url), 2000);
          };
          q.recorder.start();
          q.recording = true;
          btnEl.textContent = 'Stop';
        } catch(err){ console.error(err); alert('Impossibile registrare videocamera in questo browser.'); }
      }
      return;
    }
    if(q.recording){
      q.recorder.stop();
      q.recording=false;
      btnEl.textContent='Registra';
    } else {
      try {
        const fps = Math.min(60, Math.max(5, parseInt(q.sliderVel.value || 30)));
        const stream = q.canvas.captureStream(fps);
        q.recordedChunks = [];
        q.recorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
        q.recorder.ondataavailable = e => { if(e.data && e.data.size) q.recordedChunks.push(e.data); };
        q.recorder.onstop = () => {
          const blob = new Blob(q.recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a'); a.href = url; a.download = `Monitor_recording.webm`; a.click();
          setTimeout(()=>URL.revokeObjectURL(url), 2000);
        };
        q.recorder.start();
        q.recording=true;
        btnEl.textContent='Stop';
      } catch(err){
        console.error("Record error:", err);
        alert("Il browser potrebbe non supportare la registrazione di MediaRecorder per questo formato.");
      }
    }
  }
  function renderQuadrant(q){
    if(!q.active) {
      q.ctx.clearRect(0, 0, q.canvas.width, q.canvas.height);
      return;
    }
    if(q.tipo === 'webcam'){
      applyVideoFilters(q);
      return;
    }
    q.grayscale = !!q.grayscale;
    q.invert = !!q.invert;
    q.pareidolia = !!q.pareidolia;
    q.dither = true;
    switch(q.tipo){
      case 'plasma': drawPlasmaClouds(q); break;
      case 'plasmaAnim': drawPlasmaAnim(q); break;
      case 'smoke': drawSmokeNoise(q); break;
      case 'smokeswirl': drawSmokeSwirl(q); break;
      case 'smokewisp': drawSmokeWisps(q); break;
      case 'liquid': drawLiquidPlasma(q); break;
      case 'fire': drawFirePlasma(q); break;
      case 'nebula': drawNebulaNoise(q); break;
      case 'staticdrift': drawStaticDrift(q); break;
      case 'tubocatodico': drawTuboCatodico(q); break;
      case 'waterplasma': drawWaterPlasma(q); break;
      case 'badtv': drawBadtv(q); break;
      default: drawPlasmaClouds(q); break;
    }
  }
  function animate(){
    const now = performance.now();
    quadranti.forEach(q => {
      const targetFps = Math.max(5, Math.min(60, parseInt(q.sliderVel.value || 30)));
      const minDelta = 1000 / targetFps;
      if(!q._lastDraw || (now - q._lastDraw) >= minDelta){
        renderQuadrant(q);
        q._lastDraw = now;
      }
    });
    requestAnimationFrame(animate);
  }
  animate();
  window.addEventListener('resize', () => {
    quadranti.forEach(q => {
      if(q.active) {
        resizeCanvasToDisplaySize(q.canvas);
      }
    });
  });
  quadranti.forEach(q => resizeCanvasToDisplaySize(q.canvas));
  document.querySelectorAll('.quadrante').forEach(quad => {
    quad.addEventListener('dblclick', function(event) {
      event.preventDefault();
      if (this.classList.contains('expanded')) {
        this.classList.remove('expanded');
        document.querySelectorAll('.monitor-spento').forEach(spento => {
          spento.style.display = 'none';
          if (spento.parentElement.classList.contains('off')) {
            spento.style.display = 'block';
          }
        });
      } else {
        document.querySelectorAll('.quadrante').forEach(q => {
          q.classList.remove('expanded');
        });
        this.classList.add('expanded');
        document.querySelectorAll('.monitor-spento').forEach(spento => {
          spento.style.display = 'none';
        });
      }
    });
  });
  const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  const fullscreenBtn = document.querySelector('.fullscreen-btn');
  const exitFullscreenBtn = document.querySelector('.exit-fullscreen-btn');
  if (isMobileDevice) {
    fullscreenBtn.style.display = 'none';
    exitFullscreenBtn.style.display = 'none';
  } else {
    fullscreenBtn.addEventListener('click', function() {
      const elem = document.documentElement;
      if (elem.requestFullscreen) {
        elem.requestFullscreen();
      } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen();
      } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
      } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
      }
    });
    exitFullscreenBtn.addEventListener('click', function() {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    });
    document.addEventListener('fullscreenchange', updateFullscreenButton);
    document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
    document.addEventListener('mozfullscreenchange', updateFullscreenButton);
    document.addEventListener('MSFullscreenChange', updateFullscreenButton);
    function updateFullscreenButton() {
      if (document.fullscreenElement || document.webkitFullscreenElement ||
          document.mozFullScreenElement || document.msFullscreenElement) {
        fullscreenBtn.style.display = 'none';
        exitFullscreenBtn.style.display = 'block';
      } else {
        fullscreenBtn.style.display = 'block';
        exitFullscreenBtn.style.display = 'none';
      }
    }
  }
  const videoFrameBtn = document.querySelector('.video-frame-btn');
  const videoFramePage = document.getElementById('video-frame-page');
  const backToMainBtn = document.getElementById('back-to-main');
  const videoFileInput = document.getElementById('videoFileInput');
  const createFramesBtn = document.getElementById('create-frames-btn');
  const videoFrameCanvas = document.getElementById('video-frame-canvas');
  const videoFrameCtx = videoFrameCanvas.getContext('2d');
  const frameInfo = document.getElementById('frameInfo');
  const prevFrameBtn = document.getElementById('prevFrame');
  const nextFrameBtn = document.getElementById('nextFrame');
  const applyNegativeBtn = document.getElementById('applyNegative');
  const applyGrayscaleBtn = document.getElementById('applyGrayscale');
  const applyUVBtn = document.getElementById('applyUV');
  const applyMirrorBtn = document.getElementById('applyMirror');
  const resetFiltersBtn = document.getElementById('resetFilters');
  const saveFrameBtn = document.getElementById('saveFrame');
  const viewAllFramesBtn = document.getElementById('viewAllFrames');
  const allFramesModal = document.getElementById('all-frames-modal');
  const allFramesGrid = document.getElementById('all-frames-grid');
  const closeAllFramesBtn = document.getElementById('closeAllFrames');
  const extractionFpsSelect = document.getElementById('extractionFps');
  let videoElement = null;
  let videoFrames = [];
  let currentFrameIndex = 0;
  let totalFramesExtracted = 0;
  let zoomLevel = 1.0;
  let canvasOffsetX = 0;
  let canvasOffsetY = 0;
  let isNegativeActive = false;
  let isGrayscaleActive = false;
  let isUVActive = false;
  let isMirrorActive = false;
  let isDragging = false;
  let dragStartX = 0;
  let dragStartY = 0;
  let shouldCancelExtraction = false;
  let initialDistance = 0;

  videoFrameBtn.addEventListener('click', async () => {
    document.getElementById('main').style.display = 'none';
    videoFramePage.classList.add('active');
    fullscreenBtn.style.display = 'none';
    exitFullscreenBtn.style.display = 'none';
  });

  backToMainBtn.addEventListener('click', () => {
    videoFramePage.classList.remove('active');
    document.getElementById('main').style.display = 'flex';
    if (videoElement) {
      videoElement.pause();
      videoElement.src = '';
      videoElement.load();
      videoElement = null;
    }
    videoFrames = [];
    currentFrameIndex = 0;
    totalFramesExtracted = 0;
    zoomLevel = 1.0;
    canvasOffsetX = 0;
    canvasOffsetY = 0;
    resetFilterStates();
    updateFrameInfo();
    applyCanvasTransform();
    if (videoFrameCanvas && videoFrameCtx) {
      videoFrameCtx.clearRect(0, 0, videoFrameCanvas.width, videoFrameCanvas.height);
      videoFrameCanvas.width = 1;
      videoFrameCanvas.height = 1;
    }
    if (videoFileInput) {
      videoFileInput.value = '';
    }
    const createFramesBtn = document.getElementById('create-frames-btn');
    if (createFramesBtn) {
      createFramesBtn.textContent = "Crea Fotogrammi";
      createFramesBtn.disabled = false;
    }
    if (!isMobileDevice) {
      fullscreenBtn.style.display = 'block';
    }
  });

videoFileInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;

    // 👇 RESET COMPLETO ANCHE QUI!
    videoFrames = [];
    currentFrameIndex = 0;
    totalFramesExtracted = 0;
    zoomLevel = 1.0;
    canvasOffsetX = 0;
    canvasOffsetY = 0;
    resetFilterStates();
    updateFrameInfo();
    applyCanvasTransform();
    if (videoFrameCanvas && videoFrameCtx) {
      videoFrameCtx.clearRect(0, 0, videoFrameCanvas.width, videoFrameCanvas.height);
    }

    const url = URL.createObjectURL(file);
    if (videoElement) {
      videoElement.pause();
      videoElement.src = '';
      videoElement.load();
    }
    videoElement = document.createElement('video');
    videoElement.src = url;
});

createFramesBtn.addEventListener('click', async function() {
    if (!videoElement) {
      alert("Carica prima un video.");
      return;
    }

    // Ferma eventuali estrazioni in corso
    shouldCancelExtraction = true;

    // Svuota gli array e resetta le variabili
    videoFrames = [];
    currentFrameIndex = 0;
    totalFramesExtracted = 0;
    zoomLevel = 1.0;
    canvasOffsetX = 0;
    canvasOffsetY = 0;
    resetFilterStates();

    // Pulisci il canvas
    if (videoFrameCanvas && videoFrameCtx) {
      videoFrameCtx.clearRect(0, 0, videoFrameCanvas.width, videoFrameCanvas.height);
    }

    // Aggiorna l'interfaccia utente
    updateFrameInfo();
    applyCanvasTransform();

    // Disattiva il bottone e avvia l'estrazione
    this.disabled = true;
    this.textContent = "Creazione in corso...";

    // Avvia l'estrazione dei nuovi fotogrammi
    await extractFrames();

    // Ripristina lo stato del bottone
    this.disabled = false;
    this.textContent = "Crea Fotogrammi";

    // Mostra il primo fotogramma se estratto
    if (videoFrames.length > 0) {
      renderCurrentFrame();
      updateFrameInfo();
    }
});

  document.getElementById('cancel-frames-btn').addEventListener('click', function() {
    shouldCancelExtraction = true;
    this.style.display = 'none';
    document.getElementById('create-frames-btn').disabled = false;
    document.getElementById('create-frames-btn').textContent = "Crea Fotogrammi";
  });

  async function extractFrames() {
    if (!videoElement) return;
    const duration = videoElement.duration;
    const fps = parseInt(extractionFpsSelect.value);
    const totalFrames = Math.floor(duration * fps);
    videoFrames = [];
    totalFramesExtracted = 0;
    resetFilterStates();
    shouldCancelExtraction = false;
    const cancelBtn = document.getElementById('cancel-frames-btn');
    const createBtn = document.getElementById('create-frames-btn');
    createBtn.disabled = true;
    createBtn.textContent = "Creazione in corso...";
    cancelBtn.style.display = 'block';
    for (let i = 0; i < totalFrames; i++) {
      if (shouldCancelExtraction) {
        console.log("Estrazione fotogrammi annullata dall'utente.");
        break;
      }
      const time = i / fps;
      const frameCanvas = await seekAndCaptureFrame(time, i);
      videoFrames.push(frameCanvas);
      totalFramesExtracted = i + 1;
      updateFrameInfo();
      if (i === currentFrameIndex) {
        renderCurrentFrame();
      }
      if (i % 10 === 0) {
        await new Promise(resolve => setTimeout(resolve, 0));
      }
    }
    cancelBtn.style.display = 'none';
    createBtn.disabled = false;
    createBtn.textContent = "Crea Fotogrammi";
    if (videoFrames.length > 0) {
      renderCurrentFrame();
    }
  }

  function seekAndCaptureFrame(time, frameIndex) {
    return new Promise((resolve) => {
      videoElement.currentTime = time;
      if (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
        const metadataHandler = () => {
          videoElement.removeEventListener('loadedmetadata', metadataHandler);
          extractFrame();
        };
        videoElement.addEventListener('loadedmetadata', metadataHandler);
      } else {
        extractFrame();
      }
      function extractFrame() {
        const handler = () => {
          if (Math.abs(videoElement.currentTime - time) < 0.1) {
            videoElement.removeEventListener('timeupdate', handler);
     
            const canvas = document.createElement('canvas');
            canvas.width = videoElement.videoWidth;
            canvas.height = videoElement.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
            resolve(canvas);
          }
        };
        videoElement.addEventListener('timeupdate', handler);
      }
    });
  }

  function updateFrameInfo() {
    frameInfo.textContent = `Frame ${currentFrameIndex + 1} / ${totalFramesExtracted}`;
  }

  function applyCanvasTransform() {
    videoFrameCanvas.style.transform = `translate(${canvasOffsetX}px, ${canvasOffsetY}px) scale(${zoomLevel})`;
    clampOffset();
  }

function renderCurrentFrame() {
    if (videoFrames.length === 0 || currentFrameIndex >= videoFrames.length) return;

    const frameCanvas = videoFrames[currentFrameIndex];
    const videoWidth = frameCanvas.width;
    const videoHeight = frameCanvas.height;

    const canvas = videoFrameCanvas;
    const ctx = videoFrameCtx;

   
    const containerWidth = canvas.clientWidth;
    const containerHeight = canvas.clientHeight;

    // Calcola il rapporto d'aspetto
    const videoRatio = videoWidth / videoHeight;
    const containerRatio = containerWidth / containerHeight;

    let destWidth, destHeight, destX, destY;

    if (videoRatio > containerRatio) {
        // video più largo → limita alla larghezza
        destWidth = containerWidth;
        destHeight = destWidth / videoRatio;
    } else {
        // video più alto → limita all'altezza
        destHeight = containerHeight;
        destWidth = destHeight * videoRatio;
    }

    // Centra l'immagine
    destX = (containerWidth - destWidth) / 2;
    destY = (containerHeight - destHeight) / 2;

    // Pulisci il canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Disegna specchiato o normale
    if (isMirrorActive) {
        ctx.save();
        ctx.translate(canvas.width, 0);
        ctx.scale(-1, 1);
        ctx.drawImage(frameCanvas, 0, 0, videoWidth, videoHeight, destX, destY, destWidth, destHeight);
        ctx.restore();
    } else {
        ctx.drawImage(frameCanvas, 0, 0, videoWidth, videoHeight, destX, destY, destWidth, destHeight);
    }

    // Applica filtri
    if (isNegativeActive || isGrayscaleActive || isUVActive) {
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i], g = data[i+1], b = data[i+2];
            if (isNegativeActive) { r = 255 - r; g = 255 - g; b = 255 - b; }
            if (isGrayscaleActive) { const avg = (r+g+b)/3; r=g=b=avg; }
            if (isUVActive) { r*=0.7; g*=0.8; b*=1.5; }
            data[i] = Math.min(255, Math.max(0, r));
            data[i+1] = Math.min(255, Math.max(0, g));
            data[i+2] = Math.min(255, Math.max(0, b));
        }
        ctx.putImageData(imgData, 0, 0);
    }

    // Reset zoom/offset (se usi trasformazioni extra)
    zoomLevel = 1.0;
    canvasOffsetX = 0;
    canvasOffsetY = 0;
    applyCanvasTransform(); // opzionale
}


  function navigateFrame(delta) {
    currentFrameIndex = Math.max(0, Math.min(videoFrames.length - 1, currentFrameIndex + delta));
    updateFrameInfo();
    renderCurrentFrame();
  }

  prevFrameBtn.addEventListener('click', () => {
    navigateFrame(-1);
  });
  nextFrameBtn.addEventListener('click', () => {
    navigateFrame(1);
  });

  document.addEventListener('keydown', function(event) {
    if (!videoFramePage.classList.contains('active')) return;
    if (event.key === 'ArrowLeft' || event.key === 'ArrowRight') {
      event.preventDefault();
    }
    if (event.key === 'ArrowLeft') {
      navigateFrame(-1);
    } else if (event.key === 'ArrowRight') {
      navigateFrame(1);
    }
  });

  applyNegativeBtn.addEventListener('click', () => {
    isNegativeActive = !isNegativeActive;
    applyNegativeBtn.classList.toggle('active', isNegativeActive);
    renderCurrentFrame();
  });
  applyGrayscaleBtn.addEventListener('click', () => {
    isGrayscaleActive = !isGrayscaleActive;
    applyGrayscaleBtn.classList.toggle('active', isGrayscaleActive);
    renderCurrentFrame();
  });
  applyUVBtn.addEventListener('click', () => {
    isUVActive = !isUVActive;
    applyUVBtn.classList.toggle('active', isUVActive);
    renderCurrentFrame();
  });
  applyMirrorBtn.addEventListener('click', () => {
    isMirrorActive = !isMirrorActive;
    applyMirrorBtn.classList.toggle('active', isMirrorActive);
    renderCurrentFrame();
  });
  resetFiltersBtn.addEventListener('click', () => {
    resetFilterStates();
    renderCurrentFrame();
  });

  function resetFilterStates() {
    isNegativeActive = false;
    isGrayscaleActive = false;
    isUVActive = false;
    isMirrorActive = false;
    applyNegativeBtn.classList.remove('active');
    applyGrayscaleBtn.classList.remove('active');
    applyUVBtn.classList.remove('active');
    applyMirrorBtn.classList.remove('active');
  }

    saveFrameBtn.addEventListener('click', () => {
    if (videoFrames.length === 0 || currentFrameIndex >= videoFrames.length) return;

    const originalFrame = videoFrames[currentFrameIndex]; // Il fotogramma originale non modificato
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // 👇 IMPORANTE: Imposta le dimensioni del canvas alle dimensioni ORIGINALI del fotogramma
    canvas.width = originalFrame.width;
    canvas.height = originalFrame.height;

    // Disegna il fotogramma originale SENZA ridimensionamento → nessun bordo nero!
    ctx.drawImage(originalFrame, 0, 0);

    // Applica eventuali filtri attivi (negativo, grigio, UV) SOLO sul canvas temporaneo
    if (isNegativeActive || isGrayscaleActive || isUVActive) {
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imgData.data;
        for (let i = 0; i < data.length; i += 4) {
            let r = data[i], g = data[i+1], b = data[i+2];
            if (isNegativeActive) { r = 255 - r; g = 255 - g; b = 255 - b; }
            if (isGrayscaleActive) { const avg = (r+g+b)/3; r=g=b=avg; }
            if (isUVActive) { r*=0.7; g*=0.8; b*=1.5; }
            data[i] = Math.min(255, Math.max(0, r));
            data[i+1] = Math.min(255, Math.max(0, g));
            data[i+2] = Math.min(255, Math.max(0, b));
        }
        ctx.putImageData(imgData, 0, 0);
    }

    // Salva il canvas temporaneo (senza bordi neri, intero fotogramma)
    const link = document.createElement('a');
    link.download = `frame_${currentFrameIndex + 1}.png`;
    link.href = canvas.toDataURL('image/png', 1.0);
    link.click();

    // Pulisci il canvas temporaneo (opzionale, ma buona pratica)
    canvas.remove();
});

  viewAllFramesBtn.addEventListener('click', () => {
    if (videoFrames.length === 0) {
      alert("Nessun fotogramma da visualizzare.");
      return;
    }
    allFramesGrid.innerHTML = '';
    const maxFramesToShow = 50;
    const framesToShow = videoFrames.slice(0, maxFramesToShow);
    framesToShow.forEach((canvas, index) => {
      const container = document.createElement('div');
      container.className = 'frame-thumbnail';
      const img = document.createElement('img');
      img.src = canvas.toDataURL('image/png', 1.0);
      const label = document.createElement('div');
      label.className = 'frame-number';
      label.textContent = `Frame ${index + 1}`;
      container.appendChild(img);
      container.appendChild(label);
      container.addEventListener('click', () => {
        currentFrameIndex = index;
        renderCurrentFrame();
        updateFrameInfo();
        allFramesModal.style.display = 'none';
      });
      allFramesGrid.appendChild(container);
    });
    if (videoFrames.length > maxFramesToShow) {
      const message = document.createElement('div');
      message.style.color = 'var(--neon-red)';
      message.style.textAlign = 'center';
      message.style.padding = '6px';
      message.textContent = `Mostrati solo i primi ${maxFramesToShow} fotogrammi su ${videoFrames.length}.`;
      allFramesGrid.appendChild(message);
    }
    allFramesModal.style.display = 'block';
  });

  closeAllFramesBtn.addEventListener('click', () => {
    allFramesModal.style.display = 'none';
  });

  const canvasContainer = document.getElementById('video-frame-canvas-container');

  function clampOffset() {
    const containerRect = canvasContainer.getBoundingClientRect();
    const canvasRect = videoFrameCanvas.getBoundingClientRect();
    const maxX = 0;
    const minX = containerRect.width - canvasRect.width;
    canvasOffsetX = Math.min(maxX, Math.max(minX, canvasOffsetX));
    const maxY = 0;
    const minY = containerRect.height - canvasRect.height;
    canvasOffsetY = Math.min(maxY, Math.max(minY, canvasOffsetY));
  }

  function getDistance(touches) {
    const dx = touches[0].clientX - touches[1].clientX;
    const dy = touches[0].clientY - touches[1].clientY;
    return Math.sqrt(dx*dx + dy*dy);
  }

  canvasContainer.addEventListener('mousedown', (e) => {
    if (e.button === 0) {
      isDragging = true;
      dragStartX = e.clientX - canvasOffsetX;
      dragStartY = e.clientY - canvasOffsetY;
      canvasContainer.style.cursor = 'grabbing';
    }
  });
  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    canvasOffsetX = e.clientX - dragStartX;
    canvasOffsetY = e.clientY - dragStartY;
    applyCanvasTransform();
  });
  document.addEventListener('mouseup', () => {
    isDragging = false;
    canvasContainer.style.cursor = 'grab';
  });
  canvasContainer.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      dragStartX = e.touches[0].clientX - canvasOffsetX;
      dragStartY = e.touches[0].clientY - canvasOffsetY;
      canvasContainer.style.cursor = 'grabbing';
      e.preventDefault();
    } else if (e.touches.length === 2) {
      isDragging = false;
      initialDistance = getDistance(e.touches);
    }
  });
  canvasContainer.addEventListener('touchmove', (e) => {
    if (e.touches.length === 1 && isDragging) {
      canvasOffsetX = e.touches[0].clientX - dragStartX;
      canvasOffsetY = e.touches[0].clientY - dragStartY;
      applyCanvasTransform();
      e.preventDefault();
    } else if (e.touches.length === 2) {
      const currentDistance = getDistance(e.touches);
      let zoomFactor = currentDistance / initialDistance;
      initialDistance = currentDistance;
      const maxScale = 3.0;
      const newScale = zoomLevel * zoomFactor;
      if (newScale <= maxScale) {
        zoomLevel = newScale;
      } else {
        zoomLevel = maxScale;
        zoomFactor = maxScale / zoomLevel;
      }
      applyCanvasTransform();
      e.preventDefault();
    }
  });
  canvasContainer.addEventListener('touchend', (e) => {
    if (e.touches.length < 2) {
      isDragging = false;
      canvasContainer.style.cursor = 'grab';
    }
  });
  canvasContainer.style.cursor = 'grab';

  const toggleSettingsBtn = document.getElementById('toggle-settings-btn');
  toggleSettingsBtn.addEventListener('click', function() {
    settingsBanner.classList.toggle('active');
    if (settingsBanner.classList.contains('active')) {
      this.textContent = "❌ Chiudi Impostazioni";
    } else {
      this.textContent = "⚙️ Impostazioni";
    }
  });
});
</script>
</body>
</html>



